[{"title":"2.链表的基本操作","url":"/2022/01/05/2-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"1676  链表的基本操作：创建，插入，删除，输出\n输入\n输入数据只有一组，第一行有n+1个整数，第一个整数是这行余下的整数数目n，后面是n个整数。这一行整数是用来初始化列表的，并且输入的顺序与列表中的顺序相反，也就是说如果列表中是1、2、3那么输入的顺序是3、2、1。\n第二行有一个整数m，代表下面还有m行。每行有一个字符串，字符串是“get”，“insert”，“delete”，“show”中的一种。如果是“get”或者“delete”，则其后跟着一个整数a，代表获得或者删除第a个元素；如果是“insert”，则其后跟着两个整数a和e，代表在第a个位置前面插入e；“show”之后没有整数。\n输出\n如果获取成功，则输出该元素；如果删除成功则输出“delete OK”；如果获取失败或者删除失败，则输出“get fail”以及“delete fail”。如果插入成功则输出“insert OK”，否则输出“insert fail”。如果是“show”则输出列表中的所有元素，如果列表是空的，则输出“Link list is empty”。注：所有的双引号均不输出。\n样例输入复制\n3 3 2 121showdelete 1showdelete 2showdelete 1showdelete 2insert 2 5showinsert 1 5showinsert 1 7showinsert 2 5showinsert 3 6showinsert 1 8showget 2\n\n样例输出复制\n1 2 3delete OK2 3delete OK2delete OKLink list is emptydelete failinsert failLink list is emptyinsert OK5insert OK7 5insert OK7 5 5insert OK7 5 6 5insert OK8 7 5 6 57\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct node&#123;\tint data;\tint length;\tstruct node *next; &#125;node,*Node;Node create(int n);void get(Node L,int i);Node insert(Node L,int i,int x);Node delet(Node L,int i);void show(Node L);int Empty(Node L);int Length(Node L);int main()&#123;\tNode L;\tchar ch[10];\tint n,s,i,a,b,x,c;\tscanf(&quot;%d&quot;,&amp;n);\tL = create(n);\tscanf(&quot;%d&quot;,&amp;s);\tfor(i = 0;i &lt; s;i++)\t&#123;\t\tscanf(&quot;%s&quot;,ch);\t\tif(!strcmp(ch,&quot;get&quot;))\t\t&#123;\t\t\tscanf(&quot;%d&quot;,&amp;a);\t\t\tif(a &lt; 1 || a &gt; Length(L))\t\t\t\tprintf(&quot;get fail\\n&quot;);\t\t\telse\t\t\t\tget(L,a);\t\t&#125;\t\telse if(!strcmp(ch,&quot;insert&quot;))\t\t&#123;\t\t\tscanf(&quot;%d%d&quot;,&amp;b,&amp;x);\t\t\tif((b &gt; Length(L)+1)||b&lt;1)\t\t\t\tprintf(&quot;insert fail\\n&quot;);\t\t\telse\t\t\t&#123;\t\t\t\tL = insert(L,b,x);\t\t\t\tprintf(&quot;insert OK\\n&quot;); \t\t\t&#125;\t\t&#125;\t\telse if(!strcmp(ch,&quot;delete&quot;))\t\t&#123;\t\t\tscanf(&quot;%d&quot;,&amp;c);\t\t\tif(c &lt; 1 || c &gt; Length(L))\t\t\t\tprintf(&quot;delete fail\\n&quot;);\t\t\telse\t\t\t&#123;\t\t\t\tL = delet(L,c);\t\t\t\tprintf(&quot;delete OK\\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse if(!strcmp(ch,&quot;show&quot;))\t\t&#123;\t\t\tif(!Empty(L))\t\t\t\tshow(L);\t\t\telse\t\t\t\tprintf(&quot;Link list is empty\\n&quot;);\t\t\t&#125;\t&#125;\treturn 0;&#125;Node create(int n)//头插法建立链表 &#123;\tNode L;\tint i;\tL = (Node)malloc(sizeof(node));\tL-&gt;next = NULL;\tL-&gt;length = n;\tfor(i = 0;i &lt; L-&gt;length;i++)\t&#123;\t\tNode p;\t\tp = (Node)malloc(sizeof(node));\t\tint x;//包括这行在内的以下三行相当于scanf(&quot;%d&quot;,&amp;p-&gt;data);\t\tscanf(&quot;%d&quot;,&amp;x);\t\tp-&gt;data = x; \t\tp-&gt;next = L-&gt;next;\t\tL-&gt;next = p; \t&#125; \treturn L;&#125;void get(Node L,int i)//获得第i个节点的值 &#123;\tNode p;\tp = L;\tfor(int j=0;j &lt; i;j++)\t \tp = p-&gt;next;\tprintf(&quot;%d\\n&quot;,p-&gt;data);&#125;Node insert(Node L,int i,int x)//在第i个节点插入元素x &#123;\tNode p,pre;\tpre = L;\tp = (Node)malloc(sizeof(node));\tfor(int j=1;j&lt;i;j++)\t\tpre = pre-&gt;next;\tp-&gt;data = x;\tp-&gt;next = pre-&gt;next;\tpre-&gt;next = p;\tL-&gt;length++;\treturn L;&#125;Node delet(Node L,int i)//删除第i个节点&#123;\tNode pre;\tpre = L; \tfor(int j = 1;j &lt; i;j++)\t\tpre = pre-&gt;next;\tNode q = pre-&gt;next;\tpre-&gt;next = q-&gt;next;\tfree(q);\tL-&gt;length--;\treturn L;&#125; void show(Node L)//输出链表的值 &#123;\tNode p;\tp = L-&gt;next;\twhile(p)\t&#123;\t\tprintf(&quot;%d &quot;,p-&gt;data);\t\tp = p-&gt;next;\t\t&#125;\tprintf(&quot;\\n&quot;);&#125;int Empty(Node L)//判断链表是否为空 &#123;\treturn(L-&gt;next == NULL); &#125;int Length(Node L)//返回链表的长度 &#123;\treturn(L-&gt;length); &#125;\n\n","categories":["dotcpp"]},{"title":"1.链表合并","url":"/2021/12/31/1-%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/","content":"1052  已有a、b两个链表，每个链表中的结点包括学号、成绩。要求把两个链表合并，按学号升序排列。\n输入\n第一行，a、b两个链表元素的数量N、M,用空格隔开。 接下来N行是a的数据 然后M行是b的数据 每行数据由学号和成绩两部分组成\n输出\n按照学号升序排列的数据\n样例输入复制\n2 35 1006 893 824 952 10\n\n样例输出复制\n2 103 824 955 1006 89\n\n\n思路  先合并链表，然后使用选择法排序，对结构体中的内容进行交换，最后输出\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct student&#123;//定义节点类型 \tint num;\tfloat score;\tstruct student *next;&#125;stu,*Student; Student creat(int length)&#123;\tstu *L;\tL = (stu *)malloc(sizeof(stu));\tL-&gt;next = NULL;\tstu *r;\tr = L;//使用一个尾指针 \tint i;\tfor(i=0;i&lt;length;i++)\t&#123;\t\tstu *p;//使用尾插法建立链表 \t\tp = (stu *)malloc(sizeof(stu));\t\tscanf(&quot;%d&quot;,&amp;(p-&gt;num));\t\tscanf(&quot;%f&quot;,&amp;(p-&gt;score));\t\tr-&gt;next = p;\t\tr = p;\t&#125;\tr-&gt;next = NULL; \treturn L;&#125;Student sort(Student L1,Student L2)//先合并再排序 &#123;\tStudent temp;\ttemp = L1;\twhile(L1-&gt;next != NULL)\t&#123;\t\tL1 = L1-&gt;next;\t&#125;\t L1-&gt;next = L2-&gt;next;//将第一个链表的尾接到第二个链表的头\t free(L2);//L2的头结点为空，将其free \t stu *p,*q,t;\t for(p = temp-&gt;next;p != NULL;p = p-&gt;next)//使用选择法排序，对结构体中的学号和分数进行排序 \t &#123;\t \tfor(q = p-&gt;next;q != NULL;q = q-&gt;next)\t \t&#123;\t \t\tif(p-&gt;num &gt; q-&gt;num)\t \t\t&#123;\t \t\t\tt.num = p-&gt;num;\t \t\t\tp-&gt;num = q-&gt;num;\t \t\t\tq-&gt;num = t.num;\t \t\t\tt.score = p-&gt;score;\t \t\t\tp-&gt;score = q-&gt;score;\t \t\t\tq-&gt;score = t.score;\t\t\t&#125;\t\t&#125;\t &#125;\t return temp; \t //我是个傻子啊啊啊啊啊啊啊怎么会想到这么写，这是指针啊！循环条件都不对！\t /*int i,j,t1,t2;  \t for(i=0;i&lt;length;i++)\t &#123;\t \tfor(j=0;j&lt;length-j-1;j++)\t \t&#123;\t \t\tif(temp-&gt;num &gt; temp-&gt;next-&gt;num)//使用冒泡法对结构体中的学号进行排序，并交换学号和分数 \t \t\t&#123;\t \t\t\tt1 = temp-&gt;num;\t\t\t\ttemp-&gt;num = temp-&gt;next-&gt;num;\t\t\t\ttemp-&gt;num = t2;\t\t\t\tt2 = temp-&gt;score;\t\t\t\ttemp-&gt;score = temp-&gt;next-&gt;score;\t\t\t\ttemp-&gt;next-&gt;score = t2;\t\t\t&#125;\t\t&#125;\t &#125;*/&#125;int main()&#123;\tint x,y;\tscanf(&quot;%d%d&quot;,&amp;x,&amp;y);\tStudent a = creat(x);\tStudent b = creat(y);\tStudent c = sort(a,b);    if(c)&#123;\twhile(c-&gt;next!= NULL)&#123;\t\tc = c-&gt;next;\t\tprintf(&quot;%d %.0f\\n&quot;,c-&gt;num,c-&gt;score);\t\t\t&#125;  &#125;\treturn 0; &#125;\n\n总结\n\n在使用malloc函数给指针分配空间后没有判空\n\n在使用typedef重命名时容易分不清，如本题中的stu，和student，Student\n\n我这次是这样写的p = (student *)malloc(sizeof(Student));scanf(“%d”,&amp;x);scanf(“%f”,&amp;y);\n 琨琨说一般这样写，虽然我写的也没错p-&gt;num=xp-&gt;score=y\n\n头结点为空，在遍历，循环的时候应该注意\n\n\n最后！其实这道题不难，但是因为好久没有学习了，所以就花了很长时间，敲代码也没有思路，要应以为戒！\n万事开头难啊真的是！\n","categories":["dotcpp"]},{"title":"hello哇","url":"/2021/12/31/hello%E5%93%87/","content":"欢迎来到苹果的小世界^~^\n"},{"title":"3.进制转换（栈）","url":"/2022/01/10/3-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%A0%88%EF%BC%89/","content":"1055 输入一个１０进制正整数，然后输出它所对应的八进制数。\n思路：除8取余倒计法（下面也是入栈出栈以及输出的基本操作。）\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123;\tint data;\tstruct node *next;&#125;Node;typedef struct stack&#123;\tNode *top;\tint count;&#125;Link_Stack;Link_Stack *Create();Link_Stack *Push(Link_Stack *p,int a);Link_Stack *Pop(Link_Stack *p);int Show(Link_Stack *p);//创建栈Link_Stack *Create()&#123;\tLink_Stack *p;\tp = (Link_Stack*)malloc(sizeof(Link_Stack));\tif(p == NULL)\t\texit(0);\tp-&gt;count = 0;\tp-&gt;top = NULL;\treturn p;&#125; //入栈Link_Stack *Push(Link_Stack *p,int a)&#123;\tif(p == NULL)\t\treturn NULL;\tNode *L;\tL = (Node *)malloc(sizeof(Node));\tL-&gt;data = a;\tL-&gt;next = p-&gt;top;\tp-&gt;top = L;\tp-&gt;count++;\treturn p;\t&#125; //出栈Link_Stack *Pop(Link_Stack *p)&#123;\tNode *L;\tL = p-&gt;top;\tif(p-&gt;top == NULL)\t\treturn p;\telse \t&#123;\t\tp-&gt;top = p-&gt;top-&gt;next;\t\tfree(L);\t\tp-&gt;count--;\t\treturn p;\t\t&#125; &#125; //输出int Show(Link_Stack *p)&#123;\tNode *L;\tL = p-&gt;top;\tif(p-&gt;top == NULL)\t return 0;\twhile(L != NULL)\t&#123;\t\tprintf(&quot;%d&quot;,L-&gt;data);\t\tL = L-&gt;next;\t&#125;\treturn 0;&#125; int main()&#123;\tint num;\tscanf(&quot;%d&quot;,&amp;num);\tLink_Stack *p = Create();\twhile(num != 0)&#123;\t\tint a=num%8;\t\tPush(p,a);\t\tnum=num/8;\t&#125;\tShow(p);\treturn 0;&#125; \n\n","categories":["dotcpp"]}]